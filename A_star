import heapq


def a_star(graph, start, goal, h):
    """
    A* algorithm to find shortest path from start to goal.

    graph : dict
        Key = node, Value = list of tuples (neighbor, cost)
    start : str
        Start node
    goal : str
        Goal node
    h : dict
        Heuristic values for each node
    """
    # Priority queue: stores (f = g + h, node)
    visited = set()
    pq = []
    parent = {}
    g_cost = {}
    heapq.heappush(pq, (h[start], start))  # f = g + h, g(start)=0

    parent[start] = None  # to reconstruct path
    g_cost[start] = 0  # actual cost from start to node

    while pq:
        f, node = heapq.heappop(pq)

        if node in visited:
            continue
        visited.add(node)

        # Goal reached → reconstruct path
        if node == goal:
            path = []
            while node is not None:
                path.append(node)
                node = parent[node]
            print("Total cost:", g_cost[goal])
            return path[::-1]  # start → goal

        # Explore neighbors
        for neighbor, cost in graph.get(node, []):
            new_cost = g_cost[node] + cost
            # If neighbor not visited or new g is better
            if neighbor not in g_cost or new_cost < g_cost[neighbor]:
                g_cost[neighbor] = new_cost
                f_neighbor = new_cost + h[neighbor]
                parent[neighbor] = node
                heapq.heappush(pq, (f_neighbor, neighbor))

    return None  # goal not found


# ---------------- Example Graph ----------------
graph = {
    'S': [('A', 3), ('B', 2)],
    'A': [('S', 3), ('C', 4), ('D', 2)],
    'B': [('S', 2), ('E', 5), ('F', 1)],
    'C': [('A', 4)],
    'D': [('A', 2)],
    'E': [('B', 5), ('G', 2)],
    'F': [('B', 1)],
    'G': [('E', 2)]
}

# Heuristic values (estimate to goal 'G')
h = {
    'S': 7,
    'A': 6,
    'B': 1,
    'C': 5,
    'D': 3,
    'E': 2,
    'F': 1,
    'G': 0
}

# Run A* algorithm
path = a_star(graph, 'S', 'G', h)
print("Path:", path)
